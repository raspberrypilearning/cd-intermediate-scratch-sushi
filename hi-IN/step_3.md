## ड्राइंग पैटर्न

अब आपको एक प्रोग्राम मिला है जो एक रेखा खींचता है, लेकिन यह केवल एक रेखा खींचता है। वह थोड़ा नीरस है! आप `forever`{:class="block3control"} लूप का हमेशा के लिए उपयोग कर सकते हैं बार-बार कुछ draw करने के लिए.. तब आपको ड्रॉइंग मिल जाएगी जो सब से हट कर होगी!

तो आपको एक अलग प्रकार के लूप का उपयोग करने की आवश्यकता है जिसे `कहा जाता है जब तक दोहराएं`{:class"block3control"}, जो आपको **नियंत्रण में भी मिलेगा** अनुभाग। इस प्रकार का लूप बार-बार कुछ और करेगा, **जब तक** एक सच्ची / झूठी शर्त पूरी की जाती है।

--- task ---

एक `तक दोहराएं`{:class="block3control"} ब्लॉक से **नियंत्रण** अनुभाग, और `स्थानांतरित करें`{:class="block3motion"} और `बारी`{:class="block3motion"} इसके अंदर ब्लॉक करता है, जैसे:

```blocks3
+    repeat until <> 
        move (50) steps
        turn cw (15) degrees
    end
```

--- /task ---

--- task ---

अब कार्यक्रम को चलाने के लिए हरी झंडी पर क्लिक करें और देखें कि क्या होता है। आप दो चीजों पर ध्यान देंगे: कलम हमेशा स्टेज के बीच की ओर एक रेखा खींचकर शुरू होती है, और यह किनारे पर नहीं रुकती है।

--- /task ---

--- collapse ---
---
title: कलम ऐसा क्यों करता है?
---

कलम हमेशा बीच की दिशा में खींचना शुरू कर देती है, क्योंकि पहले **गति** `पेन डाउन के बाद चलने वाला ब्लॉक`{:class="block3extensions"} ब्लॉक है `x पर जाएं: 0 y: 0`{:class="block3motion"}। तो कलम एक रेखा खींचेगी क्योंकि यह मंच के केंद्र तक जाती है।

कलम स्टेज के किनारे पर नहीं रुकती, क्योंकि आपने अभी तक `को दोहराया नहीं है`{:class="block3control"} लूप यह किस स्थिति की जाँच कर रहा है। इसका मतलब है कि स्थिति कभी पूरी नहीं हो सकती है, इसलिए लूप चालू और चालू रहेगा। इसका मतलब है कि अभी, लूप हमेशा की तरह `काम कर रहा है`{:class="block3control"} लूप।

--- /collapse ---

--- task ---

`पर जाएँ x: 0 y: 0 पर जाएँ`{:class="block3motion"} ब्लॉक से पहले `कलम नीचे`{:class="block3extensions"} ब्लॉक करें और जोड़ें **अनुभाग**, एक `कलम`{:class="block3extensions"} अपने कोड की शुरुआत में सही ब्लॉक करें।

--- /task ---

अपने `को ठीक करने के लिए समय तक दोहराएं`{:class="block3control"} लूप ताकि आप जब चाहें इसे रोक दें। आप यह पता लगाने की कोशिश कर रहे हैं कि क्या (अदृश्य) स्प्राइट स्टेज के किनारे को छू रहा है, इसलिए आपको एक **सेंसिंग की आवश्यकता है** ब्लॉक - इस मामले में, `छू?`{:class="block3sensing"} ब्लॉक।

--- task ---

एक `स्पर्श करें?`{:class="block3sensing"} अपने `ब्लॉक में तब तक दोहराएं जब तक कि`{:class="block3control"} लूप, और `किनारे का चयन करें`{:class="block3sensing"}। तब तक चलने वाला लूप **तक** (अदृश्य) स्प्राइट चरण के किनारे को छूता है।

```blocks3
    pen down
+    repeat until <touching [edge v] ?> 
        move (50) steps
        turn cw (15) degrees
    end
```

--- /task ---

--- task ---

`चाल में चरणों की संख्या बदलें`{:class="block3motion"} ब्लॉक को `5`, और जाँच करें कि आपके परीक्षण से पहले आपका कार्यक्रम इससे मेल खाता है:

```blocks3
    when green flag clicked
    pen up
    hide
    clear
    go to x: (0) y: (0)
    set pen color to [#4a6cd4]
    pen down
    repeat until <touching [edge v] ?> 
        move (5) steps
        turn cw (15) degrees
    end
```

--- /task ---

यदि आप अभी कोड चलाते हैं, तो आप देखेंगे कि पेन ड्रॉइंग स्टेज पर रहता है।

केवल इतना ही नहीं, बल्कि आपका कार्यक्रम एक सर्कल-ड्राइंग प्रोग्राम में बदल गया है! यहाँ क्या हो रहा है कि उन 15-डिग्री मोड़ अंततः 360 डिग्री तक जुड़ जाते हैं, और इसलिए आपकी कलम एक पूर्ण चक्र में बदल जाती है। आप इसे हर बार थोड़ा लंबा कदम उठाने के लिए थोड़ा आगे बढ़ने के तरीके को बदलने जा रहे हैं, ताकि यह बाहर निकल जाए। इसके लिए, आपको **चर की आवश्यकता होगी** ।

वेरिएबल्स को मूल रूप से उन स्थानों या अन्य सूचनाओं को संग्रहीत करने के लिए लेबल किया जाता है जिनकी आपको परवाह है। आप उन्हें **चर में बना सकते हैं** खंड खंड।

--- task ---

`चरण नामक एक चर बनाएं`{:class="block3variables"}, और फिर `चरणों को 0 में जोड़ें`{:class="block3variables"} आपके कार्यक्रम की शुरुआत में ब्लॉक करें।

```blocks3
    when green flag clicked
+   set [steps v] to [0]
    pen up
```

--- /task ---

--- task ---

फिर `चरणों`{:class="block3variables"} के मान का उपयोग करें `5` के बजाय `चाल में`{:class="block3motion"} ब्लॉक करें, और `चरणों को 1 से बदलें`{:class="block3variables"} आपके लूप के हिस्से के रूप में

```blocks3
    pen down
    repeat until <touching [edge v] ?> 
+       move (steps) steps
        turn cw (76) degrees
+        change [steps v] by (1)
    end
```

--- /task ---

क्या आपको लगता है कि यह मायने रखता है कि आप लूप में `को 1 से कैसे बदल सकते हैं`{:class="block3variables"} ब्लॉक?

--- collapse ---
---
title: सही क्रम में कोड डालना
---

जब आप निर्णय लेते हैं कि किस ब्लॉक को ब्लॉक करना है, तो सोचें कि प्रत्येक ब्लॉक क्या करता है और आप अपना कोड क्या करना चाहते हैं।

इस मामले में, आप चाहते हैं कि कलम आगे बढ़े, फिर मुड़ें और फिर से आगे बढ़ें। हर बार जब ऐसा होता है, तो आप एक अतिरिक्त कदम बढ़ाना चाहते हैं।

तो यह समझ में आता है `चरण 1 को बदलने के लिए`{:class="block3variables"} ब्लॉक **के बाद** `चाल`{:class="block3motion"} ब्लॉक। हालांकि, बढ़ने के बाद, यह वास्तव में मायने नहीं रखता है कि क्या कलम पहले बदल जाती है और फिर चरणों की संख्या बदल जाती है, या यदि चरणों की संख्या पहले बदल जाती है और फिर कलम बदले।

--- /collapse ---

--- task ---

अब प्रोग्राम को चलाएं, और आसपास की डिग्रियों की संख्या को बदलने का भी प्रयास करें (`76` और `120`)!

--- /task ---