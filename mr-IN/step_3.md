## रेखांकन नमुने

आता आपल्याकडे एक प्रोग्राम आहे जो रेषा रेखाटतो, परंतु तो केवळ एक रेखा काढतो. ते थोडे कंटाळवाणे आहे! आपण `forever`{:class="block3control"} लूप चा वापर करून एखादी गोष्ट पुन्हा पुन्हा रेखाटू शकतो, परंतु अश्या पद्धतीने काढलेली रेखाचित्र आपल्या रेखांकन स्टेजच्या बाहेर जातील!

त्यामुळे आपण `repeat until`{:class="block3control"} yया एका वेगळ्या प्रकारच्या लूपचा वापर करूया, जे आपल्याला **Control** विभागात सापडेल. या प्रकारचे लूप पुन्हा पुन्हा एखादी गोष्ट करेल, **जोपर्यंत ** खरी/चुकीची अट पूर्ण केली जात नाही.

\--- task \---

आता **Control** विभागातून `repeat until`{:class="block3control"} ब्लॉक घ्या आणि त्यामध्ये `move`{:class="block3motion"} आणि `turn`{:class="block3motion"} ब्लॉक्स घाला:

```blocks3
+    repeat until <> 
        move (50) steps
        turn cw (15) degrees
    end
```

\--- /task \---

\--- task \---

प्रोग्राम काही वेळा चालविण्यासाठी हिरव्या झेंड्यावर क्लिक करा आणि काय होते ते पहा. आपल्याला दोन गोष्टी लक्षात येतील: पेन नेहमी रेखांकन स्टेजच्या मध्यभागी रेष रेखाटणे सुरू करतो आणि रेखांकन स्टेजच्या काठावर थांबत नाही.

\--- /task \---

## \--- collapse \---

## title: पेन असे का करतो?

पेन नेहमीच मध्यभागाच्या दिशेने रेखांकन करण्यास सुरवात करतो, कारण `go to x: 0 y: 0`{:class="block3motion"} नावाचा प्रथम **Motion** हा ब्लॉक `pen down`{:class="block3extensions"} <1> या ब्लॉकनंतर कार्यरत असतो. त्यामुळे रेखांकन स्टेजच्या मध्यभागी जाताना पेन एक रेष रेखाटतो.

रेखांकन स्टेजच्या काठावर पेन थांबत नाही, कारण आपण अद्याप `repeat until`{:class="block3control"} 0> लूपला कोणती स्थिती तपासायची आहे हे सांगितलेले नाही. ह्याचा अर्थ अट कधीच पूर्ण होणार नाही, म्हणून लूप चालू राहील. ह्याचा अर्थ असा आहे की सध्या, हे लूप `forever`{:class="block3control"} लूप सारखे कार्य करत आहे.

\--- /collapse \---

\--- task \---

आता, `go to x: 0 y: 0`{:class="block3motion"} ब्लॉकला `pen down`{:class="block3extensions"} ब्लॉकच्या आधी जोडा आणि **Pen** विभागातून `pen up`{:class="block3extensions"} ब्लॉक तुम्ही बनवलेल्या कोडच्या सर्वात आधी जोडा.

\--- /task \---

आता वेळ आली आहे `repeat until`{:class="block3control"} लूप ठीक करण्याची म्हणजे आपल्याला पाहिजे तिथे ते थांबेल. तुम्ही, (अदृश्य) स्प्राईट रेखांकन स्टेजच्या काठाला स्पर्श करत आहे की नाही, हे शोधून काढण्याचा प्रयत्न करत आहात. ह्याकरिता आपणास **Sensing** ब्लॉक - या प्रकरणात, `touching ?`{:class="block3sensing"} ब्लॉकची गरज पडेल.

\--- task \---

एक `touching ?`{:class="block3sensing"} ब्लॉक आपल्या `repeat until`{:class="block3control"} लूपमध्ये जोडा, आणि `edge`{:class="block3sensing"} निवडा. नंतर हा लूप तो पर्यंत चालेल **जोपर्यंत** (अदृश्य) स्प्राईट रेखांकन स्टेजच्या काठाला स्पर्श करत नाही.

```blocks3
    pen down
+    repeat until <touching [edge v] ?> 
        move (50) steps
        turn cw (15) degrees
    end
```

\--- /task \---

\--- task \---

त्या `move`{:class="block3motion"} ब्लॉक मधील चरणांची संख्या `5` वर अवरोधित करा, आणि चाचणी घेण्यापूर्वी आपला प्रोग्राम याच्याशी जुळत असल्याचे तपासा:

```blocks3
    when green flag clicked
    pen up
    hide
    clear
    go to x: (0) y: (0)
    set pen color to [#4a6cd4]
    pen down
    repeat until <touching [edge v] ?> 
        move (5) steps
        turn cw (15) degrees
    end
```

\--- /task \---

आपण आत्ता हा कोड चालवल्यास, पेन रेखांकन स्टेजच्या बाहेर जात नाही हे दिसेल.

फक्त तेच नाही, तर आपला प्रोग्रॅम आता वर्तुळ-रेखाचित्र देखील काढू शकतो! येथे काय होत आहे की अनेक 15-डिग्री वळणे जोडून अखेरीस 360 डिग्री पर्यंत वाढ होते आणि म्हणून आपला पेन संपूर्ण वर्तुळ रेखाटू शकतो. प्रत्येक वेळी थोडे लांब पाऊल टाकण्यासाठी आपण हालचाली करणारे थोडेसे मार्ग बदलणार आहोत. ह्यासाठी आपल्याला **variable** आवश्यकता भासेल.

व्हेरिएबल्स आपणास महत्त्वाच्या असणार्‍या नंबर किंवा इतर माहिती संग्रहित करण्यासाठी लेबल केलेली ठिकाणे असतात. आपण ते **Variables** ब्लॉक विभागात तयार करू शकतो.

\--- task \---

`steps`{:class="block3variables"} नावाचे व्हेरिएबल बनवा, आणि नंतर `set steps to 0`{:class="block3variables"} ब्लॉक आपल्या प्रोग्रामच्या सुरूवातीस जोडा.

```blocks3
    when green flag clicked
+   set [steps v] to [0]
    pen up
```

\--- /task \---

\--- task \---

नंतर `move`{:class="block3motion"} ब्लॉक मध्ये `5` ऐवजी `steps`{:class="block3variables"} मूल्य वापरा, आणि `change steps by 1`{:class="block3variables"} ला आपल्या लूप ला जोडा:

```blocks3
    pen down
    repeat until <touching [edge v] ?> 
+       move (steps) steps
        turn cw (76) degrees
+        change [steps v] by (1)
    end
```

\--- /task \---

आपणास असे वाटते का की आपण लूपमध्ये `change steps by 1`{:class="block3variables"} ब्लॉक कुठे मांडतो त्या मांडणी मांडणीमुळे काही फरक पडतो?

## \--- collapse \---

## title: कोड योग्य क्रमाने ठेवणे

आपण ब्लॉक कोणत्या ऑर्डरमध्ये ठेवायचे हे ठरविताना, प्रत्येक ब्लॉक काय करतो आणि आपण आपल्या कोडने काय केले पाहिजे याचा विचार करा.

या प्रकरणात, आपला पेन हलला पाहिजे, नंतर वळला व फिरला देखील पाहिजे. प्रत्येक वेळी हे केल्यावर, आपल्याला एक पाऊल पुढे टाकायचे आहे.

म्हणून `move`{:class="block3motion"} ब्लॉक **नंतर** `change steps by 1`{:class="block3variables"} हा ब्लॉक आपण जोडणार. तथापि, हलवल्यानंतर, पेन प्रथम वळला आणि नंतर चरणांची संख्या बदलली किंवा प्रथम चरणांची संख्या बदलली आणि मग पेन वळला तरी काही फरक पडत नाही.

\--- /collapse \---

\--- task \---

आता प्रोग्राम चालवा, आणि डिग्रीची संख्या बदलण्याचा प्रयत्न करा (`76` आणि `120` वापरून पहा)!

\--- /task \---